diff --git a/core/lib/Drupal/Core/Datetime/Element/Datetime.php b/core/lib/Drupal/Core/Datetime/Element/Datetime.php
index e877971bd92..e3523447cfd 100644
--- a/core/lib/Drupal/Core/Datetime/Element/Datetime.php
+++ b/core/lib/Drupal/Core/Datetime/Element/Datetime.php
@@ -79,10 +79,18 @@ public static function valueCallback(&$element, $input, FormStateInterface $form
     $element += ['#date_timezone' => date_default_timezone_get()];
 
     if ($input !== FALSE) {
-      $date_input = $element['#date_date_element'] != 'none' && !empty($input['date']) ? $input['date'] : '';
-      $time_input = $element['#date_time_element'] != 'none' && !empty($input['time']) ? $input['time'] : '';
       $date_format = $element['#date_date_element'] != 'none' ? static::getHtml5DateFormat($element) : '';
       $time_format = $element['#date_time_element'] != 'none' ? static::getHtml5TimeFormat($element) : '';
+      if ($input instanceof DrupalDateTime) {
+        $values = [
+          'date' => $input->format($date_format),
+          'time' => $input->format($time_format),
+        ];
+        $input = $values;
+      }
+
+      $date_input = $element['#date_date_element'] != 'none' && !empty($input['date']) ? $input['date'] : '';
+      $time_input = $element['#date_time_element'] != 'none' && !empty($input['time']) ? $input['time'] : '';
 
       // Seconds will be omitted in a post in case there's no entry.
       if (!empty($time_input) && strlen($time_input) == 5) {
diff --git a/core/modules/datetime/src/Plugin/views/filter/Date.php b/core/modules/datetime/src/Plugin/views/filter/Date.php
index d401917b626..213ad3fe864 100644
--- a/core/modules/datetime/src/Plugin/views/filter/Date.php
+++ b/core/modules/datetime/src/Plugin/views/filter/Date.php
@@ -7,6 +7,7 @@
 use Drupal\Core\Datetime\DrupalDateTime;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Drupal\Core\Render\Element;
 use Drupal\datetime\Plugin\Field\FieldType\DateTimeItem;
 use Drupal\datetime\Plugin\Field\FieldType\DateTimeItemInterface;
 use Drupal\views\Attribute\ViewsFilter;
@@ -230,4 +231,59 @@ protected function getOffset($time, $timezone) {
     return $origin_offset;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function buildExposedForm(&$form, FormStateInterface $form_state) {
+    parent::buildExposedForm($form, $form_state);
+
+    // Hide the date_time_element for date-only fields.
+    // What elements are visible and where they live in the form structure is
+    // really complicated. Cases to consider:
+    // - Operation is fixed and requires no elements (empty / not empty).
+    // - Operation is fixed and requires a single element (=, !=, >=, etc).
+    // - Operation is fixed and requires 2 elements (between / not between).
+    // - Operation is exposed but limited to one or more of the above.
+    // - Operation is exposed and unlimited (we have value, max and min).
+    // Instead of trying to code for all of this separately, we recursively
+    // search through the form element and any children, looking for anything
+    // of type 'datetime', and disable the time element.
+    // @see \Drupal\views\Plugin\views\filter\NumericFilter::valueForm()
+    if ($this->fieldStorageDefinition->getSetting('datetime_type') === DateTimeItem::DATETIME_TYPE_DATE) {
+      $field_identifier = $this->options['expose']['identifier'];
+      // The form elements might be encased in a wrapper, so check that first.
+      $field_wrapper = $field_identifier . '_wrapper';
+      if (isset($form[$field_wrapper])) {
+        $this->alterFormElementGranularity($form[$field_wrapper], 'day');
+      }
+      if (isset($form[$field_identifier])) {
+        $this->alterFormElementGranularity($form[$field_identifier], 'day');
+      }
+    }
+  }
+
+  /**
+   * Alters the granularity of any datetime elements in the given form element.
+   *
+   * Recursively searches all children of the element to handle nested forms.
+   *
+   * @param array $element
+   *   The form element to alter.
+   * @param string $granularity
+   *   The granularity to use for datetime form elements (e.g. 'day').
+   *
+   * @todo Expand this to handle other granularity values.
+   * @see https://www.drupal.org/project/drupal/issues/2868014
+   */
+  protected function alterFormElementGranularity(&$element, $granularity) {
+    if (isset($element['#type']) && $element['#type'] === 'datetime') {
+      if ($granularity === 'day') {
+        $element['#date_time_element'] = 'none';
+      }
+    }
+    foreach (Element::children($element) as $child) {
+      $this->alterFormElementGranularity($element[$child], $granularity);
+    }
+  }
+
 }
diff --git a/core/modules/datetime/tests/src/Functional/DateFilterTest.php b/core/modules/datetime/tests/src/Functional/DateFilterTest.php
index 87896594408..c97ae2ac372 100644
--- a/core/modules/datetime/tests/src/Functional/DateFilterTest.php
+++ b/core/modules/datetime/tests/src/Functional/DateFilterTest.php
@@ -95,14 +95,18 @@ public function testLimitExposedOperators(): void {
     $this->assertSession()->pageTextNotContains('Exception: DateTime object not set.');
 
     $this->assertSession()->optionExists('edit-field-date-value-op', '=');
+    $this->assertSession()->optionExists('edit-field-date-value-op', '!=');
     $this->assertSession()->optionNotExists('edit-field-date-value-op', '>');
     $this->assertSession()->optionNotExists('edit-field-date-value-op', '>=');
 
     // Because there are not operators that use the min and max fields, those
     // fields should not be in the exposed form.
-    $this->assertSession()->fieldExists('edit-field-date-value-value');
-    $this->assertSession()->fieldNotExists('edit-field-date-value-min');
-    $this->assertSession()->fieldNotExists('edit-field-date-value-max');
+    $this->assertSession()->fieldExists('edit-field-date-value-value-date');
+    $this->assertSession()->fieldExists('edit-field-date-value-value-time');
+    $this->assertSession()->fieldNotExists('edit-field-date-value-min-date');
+    $this->assertSession()->fieldNotExists('edit-field-date-value-min-time');
+    $this->assertSession()->fieldNotExists('edit-field-date-value-max-date');
+    $this->assertSession()->fieldNotExists('edit-field-date-value-max-time');
 
     $edit = [];
     $edit['options[operator]'] = '>';
@@ -120,9 +124,12 @@ public function testLimitExposedOperators(): void {
     $this->assertSession()->optionExists('edit-field-date-value-op', '>');
     $this->assertSession()->optionExists('edit-field-date-value-op', '>=');
 
-    $this->assertSession()->fieldExists('edit-field-date-value-value');
-    $this->assertSession()->fieldExists('edit-field-date-value-min');
-    $this->assertSession()->fieldExists('edit-field-date-value-max');
+    $this->assertSession()->fieldExists('edit-field-date-value-value-date');
+    $this->assertSession()->fieldExists('edit-field-date-value-value-time');
+    $this->assertSession()->fieldExists('edit-field-date-value-min-date');
+    $this->assertSession()->fieldExists('edit-field-date-value-min-time');
+    $this->assertSession()->fieldExists('edit-field-date-value-max-date');
+    $this->assertSession()->fieldExists('edit-field-date-value-max-time');
 
     // Set the default to an excluded operator.
     $edit = [];
diff --git a/core/modules/datetime/tests/src/Functional/Handler/FilterDateTest.php b/core/modules/datetime/tests/src/Functional/Handler/FilterDateTest.php
new file mode 100644
index 00000000000..2813fd06abc
--- /dev/null
+++ b/core/modules/datetime/tests/src/Functional/Handler/FilterDateTest.php
@@ -0,0 +1,106 @@
+<?php
+
+namespace Drupal\Tests\datetime\Functional\Handler;
+
+use Drupal\datetime\Plugin\Field\FieldType\DateTimeItem;
+use Drupal\field\Entity\FieldConfig;
+use Drupal\field\Entity\FieldStorageConfig;
+use Drupal\node\Entity\NodeType;
+use Drupal\Tests\views\Functional\ViewTestBase;
+use Drupal\views\Tests\ViewTestData;
+
+/**
+ * Tests exposed Drupal\datetime\Plugin\views\filter\Date handler.
+ *
+ * @group datetime
+ */
+class FilterDateTest extends ViewTestBase {
+
+  /**
+   * Views used by this test.
+   *
+   * @var array
+   */
+  public static $testViews = ['test_filter_datetime_exposed'];
+
+  /**
+   * Modules to enable.
+   *
+   * @var array
+   */
+  protected static $modules = ['node', 'datetime', 'datetime_test'];
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $defaultTheme = 'stark';
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp($import_test_views = TRUE, $modules = ['views_test_config']): void {
+    parent::setUp($import_test_views);
+
+    // Add a 'datetime' date field to page node bundle.
+    NodeType::create([
+      'type' => 'page',
+      'name' => 'Page',
+    ])->save();
+    $field_storage = FieldStorageConfig::create([
+      'field_name' => 'field_date',
+      'type' => 'datetime',
+      'entity_type' => 'node',
+      'settings' => ['datetime_type' => DateTimeItem::DATETIME_TYPE_DATETIME],
+    ]);
+    $field_storage->save();
+    $field = FieldConfig::create([
+      'field_name' => 'field_date',
+      'entity_type' => 'node',
+      'bundle' => 'page',
+    ]);
+    $field->save();
+
+    // Views needs to be aware of the new field.
+    $this->container->get('views.views_data')->clear();
+
+    // Load test views.
+    ViewTestData::createTestViews(get_class($this), ['datetime_test']);
+  }
+
+  /**
+   * Test 'datetime' type exposed filter.
+   */
+  public function testDateTimeExposedFilter() {
+    $this->drupalLogin($this->drupalCreateUser(['access content']));
+
+    // Verify that exposed input element exists in the output with the proper
+    // types.
+    $this->drupalGet('test-filter-datetime-exposed');
+    $this->assertSession()->elementExists('css', 'input[id="edit-field-date-value-date"][type="date"]');
+    $this->assertSession()->elementExists('css', 'input[id="edit-field-date-value-time"][type="time"]');
+
+  }
+
+  /**
+   * Test 'date' only type exposed filter.
+   */
+  public function testDateOnlyExposedFilter() {
+    $this->drupalLogin($this->drupalCreateUser(['access content']));
+
+    // Change field storage to date-only.
+    $storage = FieldStorageConfig::load('node.field_date');
+    $storage->setSetting('datetime_type', DateTimeItem::DATETIME_TYPE_DATE);
+    $storage->save();
+
+    // Views needs to be aware of the field change.
+    $this->container->get('views.views_data')->clear();
+
+    // Verify that exposed input element exists in the output with only the
+    // date component.
+    $this->drupalGet('test-filter-datetime-exposed');
+    $this->assertSession()->elementExists('css', 'input[id="edit-field-date-value-date"][type="date"]');
+    $this->assertSession()->elementNotExists('css', 'input[id="edit-field-date-value-time"]');
+
+  }
+
+}
diff --git a/core/modules/datetime/tests/src/Functional/Handler/FilterDateTest.php.~1~ b/core/modules/datetime/tests/src/Functional/Handler/FilterDateTest.php.~1~
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/core/modules/views/src/Plugin/views/filter/Date.php b/core/modules/views/src/Plugin/views/filter/Date.php
index 84d776c4b64..a5e119c108e 100644
--- a/core/modules/views/src/Plugin/views/filter/Date.php
+++ b/core/modules/views/src/Plugin/views/filter/Date.php
@@ -2,8 +2,10 @@
 
 namespace Drupal\views\Plugin\views\filter;
 
+use Drupal\Core\Datetime\DrupalDateTime;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\views\Attribute\ViewsFilter;
+use Drupal\Core\Render\Element;
 
 /**
  * Filter to handle dates stored as a timestamp.
@@ -19,6 +21,12 @@ protected function defineOptions() {
     // Value is already set up properly, we're just adding our new field to it.
     $options['value']['contains']['type']['default'] = 'date';
 
+    // We have to remove all the placeholder-related options, since those are
+    // invalid for HTML5 date elements.
+    unset($options['expose']['contains']['placeholder']);
+    unset($options['expose']['contains']['min_placeholder']);
+    unset($options['expose']['contains']['max_placeholder']);
+
     return $options;
   }
 
@@ -192,4 +200,109 @@ protected function opSimple($field) {
     $this->query->addWhereExpression($this->options['group'], "$field $this->operator $value");
   }
 
+  /**
+   * Override parent method to remove the placeholder options.
+   */
+  public function buildExposeForm(&$form, FormStateInterface $form_state) {
+    parent::buildExposeForm($form, $form_state);
+    $form['expose']['placeholder']['#access'] = FALSE;
+    $form['expose']['min_placeholder']['#access'] = FALSE;
+    $form['expose']['max_placeholder']['#access'] = FALSE;
+  }
+
+  /**
+   * Override parent method to change input type.
+   */
+  public function buildExposedForm(&$form, FormStateInterface $form_state) {
+    parent::buildExposedForm($form, $form_state);
+
+    // Change the appropriate form elements to a 'datetime' if the exposed
+    // filter is configured for 'date' input.
+    if ($this->value['type'] === 'date') {
+      // What elements are visible and where they live in the form structure is
+      // really complicated. Cases to consider:
+      // - Operation is fixed and requires no elements (empty / not empty).
+      // - Operation is fixed and requires a single element (=, !=, >=, etc).
+      // - Operation is fixed and requires 2 elements (between / not between).
+      // - Operation is exposed but limited to one or more of the above.
+      // - Operation is exposed and unlimited (we have value, max and min).
+      // Instead of trying to code for all of this separately, we see what form
+      // elements we have and where they live, and set them to datetime.
+      // Recursively search through the form element and any children, looking
+      // for anything of type 'textfield', and convert it to 'datetime'.
+      // @see \Drupal\views\Plugin\views\filter\NumericFilter::valueForm()
+      $field_identifier = $this->options['expose']['identifier'];
+      // The form elements might be encased in a wrapper, so check that first.
+      $field_wrapper = $field_identifier . '_wrapper';
+      if (isset($form[$field_wrapper])) {
+        $this->convertTextElementToDatetime($form[$field_wrapper]);
+      }
+      elseif (isset($form[$field_identifier])) {
+        $this->convertTextElementToDatetime($form[$field_identifier]);
+      }
+
+      if (in_array($this->operator, ['between', 'not between'], TRUE)) {
+        // Check the element input matches the form structure.
+        $input = $form_state->getUserInput();
+        if (isset($input[$field_identifier], $input[$field_identifier]['min']) && !is_array($input[$field_identifier]['min']) && $value = $input[$field_identifier]['min']) {
+          $date = new DrupalDateTime($value);
+          $input[$field_identifier]['min'] = [
+            'date' => $date->format('Y-m-d'),
+            'time' => $date->format('H:i:s'),
+          ];
+        }
+        if (isset($input[$field_identifier], $input[$field_identifier]['max']) && !is_array($input[$field_identifier]['max']) && $value = $input[$field_identifier]['max']) {
+          $date = new DrupalDateTime($value);
+          $input[$field_identifier]['max'] = [
+            'date' => $date->format('Y-m-d'),
+            'time' => $date->format('H:i:s'),
+          ];
+        }
+        $form_state->setUserInput($input);
+      }
+      else {
+        // Check the element input matches the form structure.
+        $input = $form_state->getUserInput();
+        if (isset($input[$field_identifier]) && !is_array($input[$field_identifier]) && $value = $input[$field_identifier]) {
+          $date = new DrupalDateTime($value);
+          $input[$field_identifier] = [
+            'date' => $date->format('Y-m-d'),
+            'time' => $date->format('H:i:s'),
+          ];
+        }
+        $form_state->setUserInput($input);
+      }
+    }
+  }
+
+  /**
+   * Finds elements in the exposed form and converts from textfield to datetime.
+   *
+   * Recursively searches all children of the element to handle nested forms.
+   *
+   * @param array $element
+   *   The form element to convert (if appropriate).
+   */
+  protected function convertTextElementToDatetime(&$element) {
+    if (isset($element['#type']) && $element['#type'] === 'textfield') {
+      $element['#type'] = 'datetime';
+    }
+    foreach (Element::children($element) as $child) {
+      $this->convertTextElementToDatetime($element[$child]);
+    }
+  }
+
+  /**
+   * Override parent method to remove 'regular_expression' as an option.
+   *
+   * Since we're operating on date fields, and have a date (and maybe time)
+   * picker as the widget (not a text field), a 'Regular expression' operation
+   * makes no sense.
+   */
+  public function operators() {
+    $operators = parent::operators();
+    unset($operators['regular_expression']);
+    return $operators;
+  }
+
 }
diff --git a/core/modules/views/tests/modules/views_test_config/test_views/views.view.test_filter_placeholder_text.yml b/core/modules/views/tests/modules/views_test_config/test_views/views.view.test_filter_placeholder_text.yml
index 6eda8684042..e1d4801cac3 100644
--- a/core/modules/views/tests/modules/views_test_config/test_views/views.view.test_filter_placeholder_text.yml
+++ b/core/modules/views/tests/modules/views_test_config/test_views/views.view.test_filter_placeholder_text.yml
@@ -206,10 +206,10 @@ display:
           entity_type: node
           entity_field: title
           plugin_id: string
-        created:
-          id: created
+        nid:
+          id: nid
           table: node_field_data
-          field: created
+          field: nid
           relationship: none
           group_type: group
           admin_label: ''
@@ -218,16 +218,15 @@ display:
             min: ''
             max: ''
             value: ''
-            type: date
           group: 1
           exposed: true
           expose:
-            operator_id: created_op
-            label: 'Authored on'
+            operator_id: nid_op
+            label: ID
             description: ''
             use_operator: true
-            operator: created_op
-            identifier: created
+            operator: nid_op
+            identifier: nid
             required: false
             remember: false
             multiple: false
@@ -251,12 +250,12 @@ display:
             default_group_multiple: {  }
             group_items: {  }
           entity_type: node
-          entity_field: created
-          plugin_id: date
-        created_1:
-          id: created_1
+          entity_field: nid
+          plugin_id: numeric
+        nid_1:
+          id: nid_1
           table: node_field_data
-          field: created
+          field: nid
           relationship: none
           group_type: group
           admin_label: ''
@@ -264,17 +263,16 @@ display:
           value:
             min: ''
             max: ''
-            value: ''
-            type: date
+            value: 'nid placeholder'
           group: 1
           exposed: true
           expose:
-            operator_id: created_with_placeholders_op
-            label: 'Authored on'
+            operator_id: nid_placeholder_op
+            label: ID
             description: ''
             use_operator: true
-            operator: created_1_op
-            identifier: created_with_placeholders
+            operator: nid_1_op
+            identifier: nid_placeholder
             required: false
             remember: false
             multiple: false
@@ -282,9 +280,9 @@ display:
               authenticated: authenticated
               anonymous: '0'
               administrator: '0'
-            placeholder: 'created placeholder'
-            min_placeholder: 'min placeholder'
-            max_placeholder: 'max placeholder'
+            placeholder: 'nid placeholder'
+            min_placeholder: 'nid min placeholder'
+            max_placeholder: 'nid max placeholder'
           is_grouped: false
           group_info:
             label: ''
@@ -298,8 +296,8 @@ display:
             default_group_multiple: {  }
             group_items: {  }
           entity_type: node
-          entity_field: created
-          plugin_id: date
+          entity_field: nid
+          plugin_id: numeric
       sorts: {  }
       title: 'Placeholder text test'
       header: {  }
@@ -313,7 +311,7 @@ display:
         groups:
           1: AND
     cache_metadata:
-      max-age: 0
+      max-age: -1
       contexts:
         - 'languages:language_content'
         - 'languages:language_interface'
@@ -329,7 +327,7 @@ display:
       display_extenders: {  }
       path: placeholder-text-test
     cache_metadata:
-      max-age: 0
+      max-age: -1
       contexts:
         - 'languages:language_content'
         - 'languages:language_interface'
diff --git a/core/modules/views/tests/src/Functional/Handler/FilterDateTest.php b/core/modules/views/tests/src/Functional/Handler/FilterDateTest.php
index 6cdc4d67393..a8eaca0449a 100644
--- a/core/modules/views/tests/src/Functional/Handler/FilterDateTest.php
+++ b/core/modules/views/tests/src/Functional/Handler/FilterDateTest.php
@@ -24,7 +24,11 @@ class FilterDateTest extends ViewTestBase {
    *
    * @var array
    */
-  public static $testViews = ['test_filter_date_between'];
+  public static $testViews = [
+    'test_filter_date_between',
+    'test_filter_date_between_exposed',
+    'test_filter_date_exposed_operators',
+  ];
 
   /**
    * {@inheritdoc}
@@ -103,6 +107,8 @@ public function testDateFilter(): void {
     $this->_testUiValidation();
     $this->_testFilterDateUI();
     $this->_testFilterDatetimeUI();
+    $this->_testExposedFilterTimestampUI();
+    $this->_testExposedFilterExposedOperator();
   }
 
   /**
@@ -295,7 +301,8 @@ protected function _testFilterDateUI() {
     $this->assertCount(1, $results);
     $this->assertEquals($this->nodes[3]->id(), $results[0]->getText());
     $this->submitForm([
-      'created' => $this->dateFormatter->format(250000, 'custom', 'Y-m-d H:i:s'),
+      'created[date]' => $this->dateFormatter->format(250000, 'custom', 'Y-m-d'),
+      'created[time]' => $this->dateFormatter->format(250000, 'custom', 'H:i:s'),
     ], 'Apply');
     $results = $this->cssSelect('.view-content .field-content');
     $this->assertCount(2, $results);
@@ -356,7 +363,203 @@ public function testExposedFilter(): void {
     $this->submitForm([], 'Save');
 
     $this->drupalGet('exposed-date-filter');
-    $this->assertSession()->fieldExists('created');
+    $this->assertSession()->fieldExists('created[date]');
+    $this->assertSession()->fieldExists('created[time]');
+  }
+
+  /**
+   * Make sure the exposed timestamp filters work.
+   */
+  protected function _testExposedFilterTimestampUI() {
+    $this->drupalLogin($this->drupalCreateUser(['access content']));
+
+    // Test the exposed "=" filter.
+    $this->drupalGet('test-filter-date-exposed');
+
+    // Verify that exposed input elements exists in the output with the proper
+    // types.
+    $date_field = $this->assertSession()->fieldExists('edit-created-date');
+    $this->assertEquals('date', $date_field->getAttribute('type'));
+    $this->assertEquals('', $date_field->getValue());
+
+    $time_field = $this->assertSession()->fieldExists('edit-created-time');
+    $this->assertEquals('time', $time_field->getAttribute('type'));
+    $this->assertEquals('', $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[3]->getTitle());
+
+    // Apply the filter.
+    $timezone = $this->config('system.date')->get('timezone.default');
+    $created = $this->nodes[1]->getCreatedTime();
+    $date = $this->dateFormatter->format($created, 'custom', 'Y-m-d', $timezone);
+    $time = $this->dateFormatter->format($created, 'custom', 'H:i:s', $timezone);
+
+    $edit = [
+      'created[date]' => $date,
+      'created[time]' => $time,
+    ];
+
+    $this->drupalGet('test-filter-date-exposed', ['query' => $edit]);
+
+    // Verify the exposed inputs have the values being filtered on.
+    $date_field = $this->assertSession()->fieldExists('edit-created-date');
+    $this->assertEquals($date, $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-time');
+    $this->assertEquals($time, $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextNotContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[3]->getTitle());
+
+    // Test the exposed "between" filter.
+    $this->drupalGet('test-filter-date-between-exposed');
+
+    // Verify that exposed input elements exists in the output with the proper
+    // types.
+    $date_field = $this->assertSession()->fieldExists('edit-created-min-date');
+    $this->assertEquals('date', $date_field->getAttribute('type'));
+    $this->assertEquals('', $date_field->getValue());
+
+    $time_field = $this->assertSession()->fieldExists('edit-created-min-time');
+    $this->assertEquals('time', $time_field->getAttribute('type'));
+    $this->assertEquals('', $time_field->getValue());
+    $date_field = $this->assertSession()->fieldExists('edit-created-max-date');
+    $this->assertEquals('date', $date_field->getAttribute('type'));
+    $this->assertEquals('', $date_field->getValue());
+
+    $time_field = $this->assertSession()->fieldExists('edit-created-max-time');
+    $this->assertEquals('time', $time_field->getAttribute('type'));
+    $this->assertEquals('', $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[3]->getTitle());
+
+    // Apply the filter.
+    $timezone = $this->config('system.date')->get('timezone.default');
+    $created = $this->nodes[1]->getCreatedTime();
+    $min_date = $this->dateFormatter->format($created - 3600, 'custom', 'Y-m-d', $timezone);
+    $min_time = $this->dateFormatter->format($created - 3600, 'custom', 'H:i:s', $timezone);
+    $max_date = $this->dateFormatter->format($created + 3600, 'custom', 'Y-m-d', $timezone);
+    $max_time = $this->dateFormatter->format($created + 3600, 'custom', 'H:i:s', $timezone);
+
+    $edit = [
+      'created[min][date]' => $min_date,
+      'created[min][time]' => $min_time,
+      'created[max][date]' => $max_date,
+      'created[max][time]' => $max_time,
+    ];
+
+    $this->drupalGet('test-filter-date-between-exposed', ['query' => $edit]);
+
+    // Verify the exposed inputs have the values being filtered on.
+    $date_field = $this->assertSession()->fieldExists('edit-created-min-date');
+    $this->assertEquals($min_date, $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-min-time');
+    $this->assertEquals($min_time, $time_field->getValue());
+    $date_field = $this->assertSession()->fieldExists('edit-created-max-date');
+    $this->assertEquals($max_date, $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-max-time');
+    $this->assertEquals($max_time, $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextNotContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[3]->getTitle());
+  }
+
+  /**
+   * Make sure the date time widgets work properly with exposed operator.
+   */
+  protected function _testExposedFilterExposedOperator() {
+    $this->drupalLogin($this->drupalCreateUser(['access content']));
+
+    // Test the exposed "=" filter.
+    $this->drupalGet('test-filter-date-exposed-operators');
+
+    // Verify that exposed input elements exists in the output with the proper
+    // types.
+    $date_field = $this->assertSession()->fieldExists('edit-created-value-date');
+    $this->assertEquals('date', $date_field->getAttribute('type'));
+    $this->assertEquals('', $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-value-time');
+    $this->assertEquals('time', $time_field->getAttribute('type'));
+    $this->assertEquals('', $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[3]->getTitle());
+
+    // Apply the filter.
+    $timezone = $this->config('system.date')->get('timezone.default');
+    $created = $this->nodes[1]->getCreatedTime();
+    $date = $this->dateFormatter->format($created, 'custom', 'Y-m-d', $timezone);
+    $time = $this->dateFormatter->format($created, 'custom', 'H:i:s', $timezone);
+
+    // When operator is exposed, when the operator is not 'between' or
+    // 'not-between', the date goes inside the value key in the array
+    // corresponding to the identifier.
+    $edit = [
+      'created[value][date]' => $date,
+      'created[value][time]' => $time,
+      'created_op' => '=',
+    ];
+
+    $this->drupalGet('test-filter-date-exposed-operators', ['query' => $edit]);
+
+    // Verify the exposed inputs have the values being filtered on.
+    $date_field = $this->assertSession()->fieldExists('edit-created-value-date');
+    $this->assertEquals($date, $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-value-time');
+    $this->assertEquals($time, $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextNotContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[3]->getTitle());
+
+    $min_date = $this->dateFormatter->format($created - 3600, 'custom', 'Y-m-d', $timezone);
+    $min_time = $this->dateFormatter->format($created - 3600, 'custom', 'H:i:s', $timezone);
+    $max_date = $this->dateFormatter->format($created + 3600, 'custom', 'Y-m-d', $timezone);
+    $max_time = $this->dateFormatter->format($created + 3600, 'custom', 'H:i:s', $timezone);
+
+    $edit = [
+      'created_op' => 'between',
+      'created[min][date]' => $min_date,
+      'created[min][time]' => $min_time,
+      'created[max][date]' => $max_date,
+      'created[max][time]' => $max_time,
+    ];
+
+    $this->drupalGet('test-filter-date-exposed-operators', ['query' => $edit]);
+
+    // Verify the exposed inputs have the values being filtered on.
+    $date_field = $this->assertSession()->fieldExists('edit-created-min-date');
+    $this->assertEquals($min_date, $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-min-time');
+    $this->assertEquals($min_time, $time_field->getValue());
+    $date_field = $this->assertSession()->fieldExists('edit-created-max-date');
+    $this->assertEquals($max_date, $date_field->getValue());
+    $time_field = $this->assertSession()->fieldExists('edit-created-max-time');
+    $this->assertEquals($max_time, $time_field->getValue());
+
+    // Verify the node list.
+    $this->assertSession()->pageTextNotContains($this->nodes[0]->getTitle());
+    $this->assertSession()->pageTextContains($this->nodes[1]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[2]->getTitle());
+    $this->assertSession()->pageTextNotContains($this->nodes[3]->getTitle());
   }
 
 }
diff --git a/core/modules/views/tests/src/Functional/Handler/FilterPlaceholderTextTest.php b/core/modules/views/tests/src/Functional/Handler/FilterPlaceholderTextTest.php
index 7adc5c6cc94..2ab997f0383 100644
--- a/core/modules/views/tests/src/Functional/Handler/FilterPlaceholderTextTest.php
+++ b/core/modules/views/tests/src/Functional/Handler/FilterPlaceholderTextTest.php
@@ -46,23 +46,23 @@ public function testPlaceholderText(): void {
     $this->assertEquals('title placeholder', $results[0]->getAttribute('placeholder'));
 
     // Numeric filter that has no placeholders configured.
-    $results = $this->cssSelect('input[name="created[value]"]');
+    $results = $this->cssSelect('input[name="nid[value]"]');
     $this->assertFalse($results[0]->hasAttribute('placeholder'));
-    $results = $this->cssSelect('input[name="created[min]"]');
+    $results = $this->cssSelect('input[name="nid[min]"]');
     $this->assertFalse($results[0]->hasAttribute('placeholder'));
-    $results = $this->cssSelect('input[name="created[max]"]');
+    $results = $this->cssSelect('input[name="nid[max]"]');
     $this->assertFalse($results[0]->hasAttribute('placeholder'));
 
     // Numeric filter that has all placeholders configured.
-    $results = $this->cssSelect('input[name="created_with_placeholders[value]"]');
+    $results = $this->cssSelect('input[name="nid_placeholder[value]"]');
     $this->assertTrue($results[0]->hasAttribute('placeholder'));
-    $this->assertEquals('created placeholder', $results[0]->getAttribute('placeholder'));
-    $results = $this->cssSelect('input[name="created_with_placeholders[min]"]');
+    $this->assertEquals('nid placeholder', $results[0]->getAttribute('placeholder'));
+    $results = $this->cssSelect('input[name="nid_placeholder[min]"]');
     $this->assertTrue($results[0]->hasAttribute('placeholder'));
-    $this->assertEquals('min placeholder', $results[0]->getAttribute('placeholder'));
-    $results = $this->cssSelect('input[name="created_with_placeholders[max]"]');
+    $this->assertEquals('nid min placeholder', $results[0]->getAttribute('placeholder'));
+    $results = $this->cssSelect('input[name="nid_placeholder[max]"]');
     $this->assertTrue($results[0]->hasAttribute('placeholder'));
-    $this->assertEquals('max placeholder', $results[0]->getAttribute('placeholder'));
+    $this->assertEquals('nid max placeholder', $results[0]->getAttribute('placeholder'));
   }
 
 }
diff --git a/core/modules/views/views.views.inc b/core/modules/views/views.views.inc
index ebde44706bb..2e90d5146af 100644
--- a/core/modules/views/views.views.inc
+++ b/core/modules/views/views.views.inc
@@ -605,6 +605,9 @@ function views_field_default_views_data(FieldStorageConfigInterface $field_stora
         if ($field_storage->getType() == 'boolean') {
           $filter = 'boolean';
         }
+        elseif ($field_storage->getType() == 'timestamp') {
+          $filter = 'date';
+        }
         break;
 
       case 'blob':
